# Pro/g/ramming Challenges v1.4?

* 00 Name generator (+ credentials)
* 01 Higher/lower, heads/tails
* 02 Temperature converter
* 03 Calculate age in seconds (with leap years)
* 04 Encryption/decryption algorithm
* 05 FizzBuzz
* 06 Rock, paper, scissors (+ lizard, Spock)
* 07 Project Euler (in every language you know)
* 08 Hangman
* 09 Love calculator
* 10 Random sentence generator
* 11 Password/passphrase generator
* 12 Internet time ((S)NTP)
* 13 Haiku generator
* 14 Magic eight ball
* 15 Collatz conjecture
* 16 Reverse a string
* 17 Eulerian path
* 18 Simple file explorer
* 19 Count words in a string (lines, sentences, paragraphs, typos, &c.)
* 20 Minesweeper
* 21 Connect four
* 22 BMI calculator
* 23 4chan thread/image downloader
* 24 Sudoku generator/solver
* 25 Maze generator/solver (random graphs/trees)
* 26 Radix (base) converter
* 27 Picross solver
* 28 Fibonacci sequence
* 29 Factorial
* 30 Cipher encryption/decryption tool (1)
* 31 Blackjack
* 32 Dungeons & Dragons with AI
* 33 Generate ASCII tree
* 34 Genetic algorithms on polygons
* 35 Benford's law
* 36 Currency converter (+ various units, comodities, etc.; + history)
* 37 Static website generator
* 38 Crossword game
* 39 Scientific calculator (CLI or GUI)
* 40 Perlin noise
* 41 Image viewer
* 42 ASCII digital clock
* 43 Dijkstra's algorithm
* 44 Text/Morse code translator (+ sound)
* 45 Tic-tac-toe
* 46 Snake game
* 47 FTP client (+ server)
* 48 Telnet server (+ client, netctat clone?)
* 49 IMP interpreter
* 50 Tetris
* 51 Conway's Game of Life (other cell. automata)
* 52 Web crawler
* 53 Text editor
* 54 RSS feed reader
* 55 RPN calculator
* 56 Mandelbrot set (+ other fractals)
* 57 Sorting algorithms (+ visualisation)
* 58 Custom markup to HTML converter (2)
* 59 N queens problem
* 60 Flow in a network (Ford-Fulkerson algo.)
* 61 Credential validator (phone, email, &c.)
* 62 Linked list (single, double)
* 63 Mastermind
* 64 Random image generator (parametric)
* 65 Ulam spiral
* 66 Klingon translator
* 67 Prime number generator using a sieve
* 68 Markov chains (random text generation)
* 69 Graphical analog clock
* 70 Two languages communicating with each other (C++ & Java, Lisp & Python, &c.)
* 71 Triangle number calculator
* 72 Typing speed calculator
* 73 Name art in ASCII
* 74 Towers of Hanoi (more disks, more poles)
* 75 Quine
* 76 IRC bot
* 77 Brainfuck interpreter (+ optimization, multiple targets)
* 78 Knight's tour
* 79 Chip-8 emulator
* 80 Geekcode generator (3.12)
* 81 Define, translate & rotate a polygon (+ other affine transformations)
* 82 Pong with variable vectors
* 83 Battleships with AI
* 84 Simple paint program
* 85 TCP chat with basic encryption
* 86 Incremental economy simulator (a la Time of Exploration)
* 87 Encrypting data in images (steganography)
* 88 Pascal's triangle
* 89 Sine wave generator from pseudorandom numbers
* 90 Flappy Bird
* 91 Fourier transform (fast or 'slow'; + visualisation)
* 92 Method ringing simulator
* 93 Binary search (n-ary)
* 94 Nintendo Oil Panic
* 95 Sierpiriski triangle
* 96 Dot & cross product of two vectors (exterior product)
* 97 Little Man computer simulation
* 98 Lisp interpreter
* 99 Enigma simulator with a configuration file (+ decrypt messages without known settings)

Notes in parentheses next to individual problems may serve as an inspiration or a pointer where to look if you're lost or helpless.
 * (1) Implement at least one of Rumkin Collection: rumkin.com/tools/cipher
 * (2) N.B.: www.mjt.me.uk/posts/falsehoods-programmers-believe-about-addresses/

# A concise how-to guide

## 0. Set up a repository

`git init` should do the job. Commit early and often.

## 1. Understand the problem

Use Generally Useful Resources(TM) to find out more information about what you're facing. If you need, use paper, draw diagrams, bite pencils.

If the problem seems too difficult, try to simplify it, find a special case that may be easier to design and implement. If it seems too easy, generalise, invent more complicated variations, perhaps try to combine with other problems.

## 2. Implement

Start with whatever language you know best or feel most comfortable with. If the problem is easy, pick a language you've never used before or one that you don't know too well yet. Don't be afraid to write ugly or nonidiomatic code as long as you understand what's going on. You can clear up the mess later.

## 3. Test

Write tests that check both the ordinary and the exceptional cases of your program. Compile/interpret/eval whatever you've written and run the tests. Find bugs, fix them and repeat. Again, commit often lest your progress disappear into the abbys.

## 4. Reimplement

Now that you have a reference implementation, you can go wild. Reimplement the task in different language this time, perhaps the one you've been meaning to learn since years ago. Try to achieve the same outcome using different techniques, use different idioms. Try to make the code as short as possible or the contrary.

## Generally Useful Resources

Google, Wikipedia, Stack Overflow

## Literature

 * Knuth: The Art of Computer Programming "TAOCP"
 * Skiena: The Algorithm Design Manual Cormen et al.: Introduction to Algorithms "CLR(S)"
 * Russell, Norvig: Artificial Intelligence: A Modern Approach
 * Abelson, Sussman: Structure and Interpretation of Computer Programs "SICP"

## See also:

 * hackerrank.com
 * codechef.com
 * codefights.com
 * projecteuler.net
 * ctftime.org
 * rosettacode.org

# Acknowledgments
Made by Anonymous in January 2015
Updated by Maciej Stanek in May 2021
